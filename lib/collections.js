// code sent to client and server
// which gets loaded before anything else (since it is in the lib folder)

// define schemas and collections
// those will be given to all templates
Schemas = {};
// Collections = {};

Items = new Mongo.Collection('items');
Times = new Mongo.Collection('times');
Attributes = new Mongo.Collection('attributes');
Tags = new Mongo.Collection('tags');

if (Meteor.isServer) {
  Times._ensureIndex({ createdBy: 1, start: 1 });
  Times._ensureIndex({ createdBy: 1, createdAt: 1 });
  Times._ensureIndex({ createdBy: 1, item: 1 });
  Times._ensureIndex({ createdAt: 1, item: 1 });

  // Items._ensureIndex( { ownedBy: 1 } );
}

// Collections.Users = new Mongo.Collection("users");

/*
Items.allow({
  insert: function () { return true; },
  update: function () { return true; },
  remove: function () { return true; }
});
*/

// TODO: write methode for needed actions

/*
Hierarchy.allow({
  insert: function () { return true; },
  update: function () { return true; },
  remove: function () { return true; }
});
*/

/*
Times.allow({
  insert: function () { return true; },
  update: function () { return true; },
  remove: function () { return true; }
});
*/
/*
Attributes.allow({
  insert: function () { return true; },
  update: function () { return true; },
  remove: function () { return true; }
});
*/

/*
Tags.allow({
  insert: function () { return true; },
  update: function () { return true; },
  remove: function () { return true; }
});
*/

// does not work :\
// Operators = new Mongo.Collection("users");

// TODO: check if password changes are still possible
// Deny all client-side updates to user documents
// see: http://guide.meteor.com/accounts.html#custom-user-data
Meteor.users.deny({
  update() {
    return true;
  },
});

Schemas.createdFields = new SimpleSchema({
  // Force value to be current date (on server) upon insert
  // and prevent updates thereafter.
  createdAt: {
    type: Date,
    label: 'Created at',
    autoValue() {
      // console.log("createdAt autovalue: ");
      // console.log(this);

      if (this.isInsert) {
        return new Date();
      } else if (this.isUpsert) {
        return { $setOnInsert: new Date() };
      }
      this.unset(); // Prevent user from supplying their own value
    },
    denyUpdate: true,
    // TODO: this fields needs to be optional, otherwise it will not withstand check()
    optional: true,
    autoform: {
      type: 'hidden',
      label: false,
    },
  },
  // Force value to be current date (on server) upon update
  // and don't allow it to be set upon insert.
  updatedAt: {
    type: Date,
    label: 'Updated at',
    // add index on last update time
    index: -1,
    autoValue() {
      // console.log("updatedAt autovalue: ");
      // console.log(this);

      if (this.isUpdate) {
        return new Date();
      }
    },
    denyInsert: true,
    optional: true,
    autoform: {
      type: 'hidden',
      label: false,
    },
  },
  createdBy: {
    type: String,
    regEx: SimpleSchema.RegEx.Id,
    label: 'Creator',

    // add index per user
    index: true,
    autoValue() {
      // console.log("createdBy autovalue: ");
      // console.log(this);
      let userid;

      try {
        userid = Meteor.userId();
      } catch (e) {
        if (this.userId) {
          userid = this.userId;
        } else {
          // userid = "b105582bc495617542af18e9";
          // userid = "000000000000000000000000";
          // userid = "autogeneratedaaaaaaaaaaa";
          // userid = "12345678901234567";
          userid = 'autogeneratedAAAA';
        }
      }

      if (this.isInsert) {
        return userid;
      } else if (this.isUpsert) {
        return { $setOnInsert: userid };
      }
      this.unset(); // Prevent user from supplying their own value
    },
    denyUpdate: true,
    // TODO: this fields needs to be optional, otherwise it will not withstand check()
    optional: true,
    autoform: {
      type: 'hidden',
      label: false,
    },
  },

  /*
	createdAt: {
		type: Date,
		label: "Created at",
		optional: true,
		//defaultValue: new Date(),
		autoValue: function() {
			console.log("createdAt autovalue: ");
			console.log(this);
			if(this.isInsert) {
				return new Date();
			}
		},
		denyUpdate: true,
		autoform: {
			type: "hidden",
			label: false,
		}
	},
	
	createdBy:{
		type: String,
		regEx: SimpleSchema.RegEx.Id,
		label: "Owner",
		autoValue: function() {
			if(this.isInsert) {
				return Meteor.userId(); 
			}
		},
		autoform: {
			type: "hidden",
			label: false,
		}
	}
	*/
});

Schemas.timeSlots = {};

// timeslots
for (timeslot in CNF.timeslots) {
  Schemas.timeSlots[`totals.$.${timeslot}`] = {
    type: Number,
    label: `Total time ${CNF.timeslots[timeslot].label}`,
    optional: true,
    autoform: {
      omit: true,
      type: 'hidden',
      label: false,
    },
  };
}

Schemas.Attributes = new SimpleSchema([
  {
    name: {
      type: String,
      label: 'Name of Attribute',
      max: 200,
    },
    type: {
      type: String,
      label: 'Type of',
      allowedValues: [
        'text',
        'textarea',
        'number',
        'boolean-checkbox',
        'date',
        'datetime-local',
        'email',
        'url',
        'password',
        'select',
      ],
      autoform: {
        options: [
          { label: 'String', value: 'text' },
          { label: 'Long Text', value: 'textarea' },
          { label: 'Number', value: 'number' },
          { label: 'Boolean', value: 'boolean-checkbox' },
          { label: 'Date', value: 'date' },
          { label: 'Datetime', value: 'datetime-local' },
          { label: 'eMail', value: 'email' },
          { label: 'Url', value: 'url' },
          { label: 'Password', value: 'password' },
          { label: 'List', value: 'select' },
        ],
      },
    },
    defaultValue: {
      type: String,
      label: 'Default Value',
      optional: true,
      max: 100,
    },
  },
  Schemas.createdFields,
]);

Attributes.attachSchema(Schemas.Attributes);

Schemas.AttributeValues = new SimpleSchema([
  {
    attribid: {
      type: String,
      label: 'Attribute',
      regEx: SimpleSchema.RegEx.Id,
      // optional: false,
      autoform: {
        type: 'hidden',
        label: false,
      },
    },
    value: {
      type: String,
      label: 'Value',
      optional: true,
    },
  },
  Schemas.createdFields,
]);

Schemas.Items = new SimpleSchema([
  {
    title: {
      type: String,
      label: 'Title',
      max: 200,

      // add index on item title
      index: false,

      // would be unique all over - should only be unique per user
      unique: false,

      autoform: {
        autocomplete: 'off',
        type: 'typeahead',
        options() {
          return Items.find({}).map(function(item) {
            return { label: item.title, value: item.title };
            // return { item.title: item.title };
          });
        },
      },
      custom() {
        if (Meteor.isClient && this.isSet) {
          console.log(`validating title for: ${this.docId}: ${this.value}`);

          Meteor.call('itemIsTitleUnique', this.value, this.docId, function(
            error,
            result
          ) {
            if (!result) {
              Items.simpleSchema()
                .namedContext('formItem')
                .addInvalidKeys([{ name: 'title', type: 'notUnique' }]);
            }
          });
        }
      },
    },
    description: {
      type: String,
      label: 'Description',
      optional: true,
      max: 2000,
    },
    /*
	path: {
		type: String,
		label: "Path",
		optional: true,
		autoform: {
			type: "hidden",
			label: false
		},
	},*/
    tags: {
      type: [String],
      regEx: SimpleSchema.RegEx.Id,
      optional: true,
      label: 'Tags',

      autoform: {
        autocomplete: 'off',
        multiple: true,
        type: 'select2',
        options() {
          return Tags.find({ type: 'item-tag' }).map(function(tag) {
            return {
              label: `${tag.name}: ${tag.value}`,
              value: tag._id,
              // title: tag.name,
            };
          });
        },
        select2Options() {
          return {
            // tags: true,
            placeholder: 'Please select tags for this item',
            // allowClear: true,
            tokenSeparators: [',', ';'],
            /*
					templateSelection: function(tag) {
						return $('<span>'+tag+'</tag>');
					},
					*/
            escapeMarkup(markup) {
              return markup;
            },
            templateResult: formatTagResult,
            templateSelection: formatTagResult,
          };
        },
      },
    },
    origin: {
      type: String,
      label: 'origin of item',
      optional: true,
      autoform: {
        type: 'hidden',
        label: false,
      },
    },
    keepOpen: {
      type: Boolean,
      label: 'keep item running',
      optional: true,
      autoform: {
        afFieldInput: {
          type: 'boolean-checkbox',
        },
      },
    },

    ownedBy: {
      type: String,
      regEx: SimpleSchema.RegEx.Id,
      label: 'Owner',
      // add index on owner
      index: true,

      optional: true,
      autoform: {
        autocomplete: 'off',
        type: 'select2',
        autofocus: 'autofocus',
        // select2Options: itemoptions,
        options() {
          return Meteor.users.find({}).map(function(us) {
            return {
              label: us.emails[0].address,
              value: us._id,
            };
          });
        },
        select2Options() {
          return {
            // tags: true,
            placeholder: 'Choose a new owner for this item',
            // allowClear: true,
            // tokenSeparators: [',', ';'],
            escapeMarkup(markup) {
              return markup;
            },
            // templateResult: formatTagResult,
            // templateSelection: formatTagResult,

            /*
					templateSelection: function(tag) {
						return $('<span>'+tag+'</tag>');
					},
					templateResult: function(tag) {
						return $('<span>'+tag+'</tag>');
					}
					*/
          };
        },
      },
      // defaultValue: this.userId, //Meteor.userId(),
      autoValue() {
        // TODO:
        // ich seh ein item nur, wenn es mir gehört
        // 		oder wenn es ein tag hat, das mir gehört
        //		oder mir freigegeben wurde
        // ich kann nur mein eigenes item bearbeiten
        // ich kann ein item nur an user weitergeben, - pff -
        //		denen ein tag gehört, oder ein tag freigegeben wurde
        //	ansonsten riskiere ich das items verschwindn.

        /*
			currentvalue = this.field("ownedBy");
			
			console.log('Autoform - ownedBy - autoValue');
			
			console.log('current value (field - ownedBy)');
			console.log(currentvalue);
			
			console.log('current UserID: ' + Meteor.userId());
			*/

        if (!this.isSet && !this.value) {
          // if current value is not set, and no new value is given ..
          // .. set current user
          console.log(`set userid for new entry: ${Meteor.userId()}`);
          return Meteor.userId();
        } else if (this.isSet && this.value != Meteor.userId()) {
          // if current value is set, and is not the current user, unset given val

          console.log(
            `updating item to a new owner:  ${Meteor.userId()} > ${this.value}`
          );
          // this.unset();
        }
      },

      custom() {
        /*
			console.log('calling ownedBy custom method: '+ 
				' isServer: '+ Meteor.isServer +
				' isClient: '+ Meteor.isClient +
				' this.docId: '+ this.docId +
				' this.isSet: '+ this.isSet +
				' this.isUpdate: '+ this.isUpdate +
				' this.userId: '+ this.userId +
				' this.value: '+ this.value +
				' this.field(ownedBy): '+ this.field('ownedBy').value);
			
			*/
        currentRow = null;
        // loading current value from collection
        if (this.docId) {
          // console.log("loading docId: " + this.docId);
          currentRow = Items.findOne({ _id: this.docId });
          // console.log("current doc: ");
          // console.log(currentRow);
        }

        // if the item does not belong to you - you can't update it!
        if (
          this.isSet &&
          this.isUpdate &&
          currentRow &&
          currentRow.ownedBy &&
          this.userId != currentRow.ownedBy
        ) {
          return 'unauthorized';
        }

        // return "notAllowed";
      },

      // denyUpdate: true,
    },

    totalsUpdatedAt: {
      type: Date,
      label: 'Totals updated at',
      optional: true,
      // defaultValue: new Date(),
      /*
		autoValue: function() {
			if(this.isInsert) {
				return new Date();
			}
			else if(this.isUpsert) {
				return new Date();
			}
			else if(this.isUpdate) {
				return new Date();
			}
		},
		*/
      // if comments is pushed, update is called
      // denyUpdate: true,
      autoform: {
        omit: true,
        type: 'hidden',
        label: false,
      },
    },

    // aggregated time sumes per user, per timeslot
    totals: {
      // setup
      // totals[user._id][timeslot] = seconds total of completed time entries (having end timestamp set)
      // totals[user._id][last_update] = timestamp of last calculation, needs to be checked against createdAt field
      type: Array,
      // regEx: SimpleSchema.RegEx.Id,
      optional: true,
      label: 'Totals',
      autoform: {
        omit: true,
        type: 'hidden',
        label: false,
      },
    },

    'totals.$': {
      type: Object,
      autoform: {
        afFieldInput: {
          options() {
            // return options object
          },
        },
        omit: true,
        label: false,
      },
    },
    'totals.$.userid': {
      type: String,
      label: 'User',
      regEx: SimpleSchema.RegEx.Id,
      autoform: {
        omit: true,
        type: 'hidden',
        label: false,
      },
    },
    attributes: {
      type: [Schemas.AttributeValues],
      optional: true,
      autoform: {
        omit: true,
        type: 'hidden',
        label: false,
      },
    },
  },
  Schemas.timeSlots,
  Schemas.createdFields,
]);

/*
Schemas.Items.addValidator(function() {

	console.log('calling addValidator method: '+
				' this.isSet: '+ this.isSet +
				' this.isUpdate: '+ this.isUpdate +
				' this.userId: '+ this.userId +
				' this.value: '+ this.value +
				' this.field(ownedBy): '+ this.field('ownedBy').value);
	
	return "notAllowed";
});
*/

Items.attachSchema(Schemas.Items);

/*
Schemas.Hierarchy = new SimpleSchema([{
	upperitem:{
		type: String,
		regEx: SimpleSchema.RegEx.Id,
		
		// TODO: does this work?
		//type: Items,
		//optional: true,
		label: "Upper-Item",
		
		autoform: {
			autocomplete: "off",
			type: "select2",
			options: function()  { 
				return Items.find({}).map(
					function(item) { 
						return { label: item.title, value: item._id } 
					}
				)
			}
		},
		
	},
	loweritem:{
		type: String,
		regEx: SimpleSchema.RegEx.Id,
		
		autoform: {
			autocomplete: "off",
			type: "select2",
			options: function()  { 
				return Items.find({}).map( 
					function(item) { 
						return { label: item.title, value: item._id } 
					}
				)
			}
		}
			
		//optional: true,
	},
}, Schemas.createdFields 
]);

Hierarchy.attachSchema(Schemas.Hierarchy);
*/

Schemas.Times = new SimpleSchema([
  {
    item: {
      type: String,
      regEx: SimpleSchema.RegEx.Id,
      // TODO: does this work?
      // type: Items,
      label: 'Item',
      // add index on time item
      index: true,

      autoform: {
        autocomplete: 'off',
        type: 'select2',
        autofocus: 'autofocus',
        // select2Options: itemoptions,
        options() {
          return Items.find({}).map(function(item) {
            return {
              label: `${item.title} - ${item.description}`,
              value: item._id,
            };
          });
        },

        /*
			afFieldInput: {
				type: 'autocomplete-input',
				placeholder: 'Item name',
				settings: function() {
					return {
						position: "bottom",
						//limit: 15,
						rules: [
							{
								collection: Items,
								//subscription: 'items.mine',
								//matchAll: true,
								//field: "title",
								field: "_id",
								filter: { createdBy: Meteor.userId() },
								template: Meteor.isClient && Template.autocompleteItem,
								noMatchTemplate: Meteor.isClient && Template.autocompleteItemNotFound,
								selector: function(match) {
									console.log("in selector :");
									console.log(match);
									return {"title" : {$regex : ".*"+match+".*"}};
								}
							}
						]
					};
				}
				
			}*/
      },
    },
    start: {
      type: Date,
      // label: 'Start Time <span class="jssetnow">set now</span>',
      label() {
        return new Spacebars.SafeString(
          'Start Time ' +
            '<span class="clickable jstimesetnow"> [now] </span> ' +
            '<span class="clickable jstimesetlatest"> [latest] </span>'
        );
      },
      // add index on start time
      index: -1,

      defaultValue: moment(new Date())
        .millisecond(0)
        .seconds(0)
        .toDate(), // moment.utc(new Date).format("DD.MM.YYYY HH:mm"), //  new Date,
      autoform: {
        // afFormGroup: {
        afFieldInput: {
          type: 'datetime-local',
          // type: "bootstrap-datetimepicker",
          placeholder: 'tt.mm.jjjj hh:mm',
          timezoneId: 'Europe/Berlin',
          offset: '+01:00',
          /*
				dateTimePickerOptions: function() {
					return {
						locale: 'de',
						sideBySide: true,
						format: 'DD.MM.YYYY HH:mm',
						extraFormats: [ 'DD.MM.YYYY HH:mm', 'DD.MM.YY HH:mm' ],
						////defaultDate: new Date,
					};
				}*/
        },
      },
      // start-date always before end-date
      custom() {
        if (this.value > new Date()) {
          return 'invalidValueStartdate';
        }

        /*
			if (this.field('end').value > 0 && this.field('end').value < this.value) {
				return "invalidValueStartdate";
			}
			*/
      },
    },
    end: {
      type: Date,
      // label: "End Time",
      label() {
        return new Spacebars.SafeString(
          'End Time ' + ' <span class="clickable jstimesetnow">[now]</span>'
        );
      },
      optional: true,
      autoform: {
        afFieldInput: {
          type: 'datetime-local',
          // type: "bootstrap-datetimepicker",
          placeholder: 'tt.mm.jjjj hh:mm',
          timezoneId: 'Europe/Berlin',
          offset: '+01:00',
          /*
				dateTimePickerOptions: function() {
					return {
						locale: 'de',
						sideBySide: true,
						format: 'DD.MM.YYYY HH:mm',
						extraFormats: [ 'DD.MM.YYYY HH:mm', 'DD.MM.YY HH:mm' ]
						//defaultDate: new Date,
					};
				}*/
        },
      },
      // end-date always after start-date
      custom() {
        if (this.value > 0 && this.field('start').value > this.value) {
          return 'invalidValueEnddate';
        }
      },
    },

    comments: {
      type: Array,
      label: '',
      optional: true,
      autoform: {
        // type: "hidden",
        label: false,
      },
    },
    'comments.$': {
      type: Object,
      autoform: {
        afFieldInput: {
          options() {
            // return options object
          },
        },
        label: false,
      },
    },
    'comments.$.comment': {
      type: String,
      label: 'Comment',
      max: 200,
    },
    'comments.$.createdAt': {
      type: Date,
      label: 'Created at',
      optional: true,
      // defaultValue: new Date(),
      autoValue() {
        console.log('createdAt autovalue for Time comment: ');
        // console.log(this);
        if (this.isInsert) {
          return new Date();
        }
      },
      // if comments is pushed, update is called
      // denyUpdate: true,
      autoform: {
        type: 'hidden',
        label: false,
      },
    },
    tags: {
      type: [String],
      regEx: SimpleSchema.RegEx.Id,
      optional: true,
      label: 'Tags',

      autoform: {
        autocomplete: 'off',
        multiple: true,
        type: 'select2',
        options() {
          return Tags.find({ type: 'time-tag' }).map(function(tag) {
            return {
              label: `${tag.name}: ${tag.value}`,
              value: tag._id,
              // title: tag.name,
            };
          });
        },
        select2Options() {
          return {
            // tags: true,
            placeholder: 'Please select tags for this time entry',
            // allowClear: true,
            tokenSeparators: [',', ';'],
            /*
					templateSelection: function(tag) {
						return $('<span>'+tag+'</tag>');
					},
					*/
            escapeMarkup(markup) {
              return markup;
            },
            templateResult: formatTagResult,
            templateSelection: formatTagResult,
          };
        },
      },
    },
    origin: {
      type: String,
      label: 'origin of time',
      optional: true,
      autoform: {
        type: 'hidden',
        label: false,
      },
    },
  },
  Schemas.createdFields,
]);

Times.attachSchema(Schemas.Times);

Schemas.Tags = new SimpleSchema([
  {
    // TODO: make sure tags (name + value) are unique - at least per user or per company
    name: {
      type: String,
      label: 'Tag Name',
      max: 200,
      autoform: {
        autocomplete: 'off',
        // type: "select2",
        type: 'typeahead',
        options() {
          return Tags.find({}).map(function(tag) {
            return { label: tag.name, value: tag.name };
          });
        },
        /*
			select2Options: function() {
				return {
					placeholder: "Please enter a tag Name",
				};
			}
			*/
        /*
			afFieldInput: {
				typeaheadOptions: {},
				typeaheadDatasets: {}
			}*/
      },
    },
    value: {
      type: String,
      label: 'Tag Value',
      max: 200,
      autoform: {
        afFieldInput: {
          placeholder: 'Enter a characteristic for this tag',
        },
      },
    },
    type: {
      type: String,
      label: 'Type of',
      allowedValues: ['item-tag', 'time-tag'],
      defaultValue: 'item-tag',
      autoform: {
        options: [
          { label: 'Tag for Item', value: 'item-tag' },
          { label: 'Tag for Timeentry', value: 'time-tag' },
        ],
      },
    },

    shared: {
      type: [String],
      // regEx: SimpleSchema.RegEx.Id,
      label: 'Share Tag with users',
      // add index on shared tags
      index: true,
      optional: true,

      autoform: {
        autocomplete: 'off',
        multiple: true,
        type: 'select2',
        options() {
          // return Meteor.users.find({_id: { $ne: Meteor.userId() }}).map( // include myself if shared
          return Meteor.users
            .find({ _id: { $ne: Meteor.userId() } })
            .map(function(us) {
              return {
                label: us.emails[0].address,
                value: us._id,
              };
            });
        },
        select2Options() {
          return {
            // tags: true,
            placeholder:
              "Choose users you want to share this tag and it's items with",
            // allowClear: true,
            tokenSeparators: [',', ';'],

            escapeMarkup(markup) {
              return markup;
            },
            // templateResult: formatTagResult,
            // templateSelection: formatTagResult,

            /*
					templateSelection: function(tag) {
						return $('<span>'+tag+'</tag>');
					},
					templateResult: function(tag) {
						return $('<span>'+tag+'</tag>');
					}
					*/
          };
        },
      },
    },

    /*
	attributes: {
		type: [Schemas.Attributes],
		//label: 'Additional Attributes for Items',
		label: '',
		optional: true,
		autoform: {
			type: "hidden",
			label: false
		},
	},*/

    attributes: {
      type: [String],
      regEx: SimpleSchema.RegEx.Id,
      optional: true,
      label: 'Attributes',

      autoform: {
        autocomplete: 'off',
        multiple: true,
        type: 'select2',
        options() {
          return Attributes.find().map(function(attrib) {
            return {
              label: `${attrib.name} [${attrib.type}]`,
              value: attrib._id,
              // title: tag.name,
            };
          });
        },
        select2Options() {
          return {
            // tags: true,
            placeholder:
              'Please select attributes for all items having this tag',
            // allowClear: true,
            tokenSeparators: [',', ';'],
            /*
					templateSelection: function(tag) {
						return $('<span>'+tag+'</tag>');
					},
					*/
            escapeMarkup(markup) {
              return markup;
            },
            templateResult: formatAttributeResult,
            templateSelection: formatAttributeResult,
          };
        },
      },
    },

    origin: {
      type: String,
      label: 'origin of tag',
      optional: true,
      autoform: {
        type: 'hidden',
        label: false,
      },
    },
  },
  Schemas.createdFields,
]);

Tags.attachSchema(Schemas.Tags);

Schemas.ItemImport = new SimpleSchema({
  format: {
    type: String,
    label: 'Format of imported Data',
    defaultValue: 'title	description	tags',
    max: 2000,
  },
  delimiter: {
    type: String,
    label: 'Delimiter',
    defaultValue: '\t',
    optional: true,
    max: 3,
  },
  data: {
    type: String,
    label: 'CSV Data to import',
    defaultValue: 'Item Title	"Item description"	tagname: tagvalue, tag, tag',
    autoform: {
      afFieldInput: {
        type: 'textarea',
        rows: 10,
      },
    },
  },
  origin: {
    type: String,
    label: 'Name the source of this list',
    max: 200,
    optional: true,
    defaultValue: `Import from ${moment().format(CNF.FORMAT_DATETIME)}`,
  },
});

Schemas.TimeImport = new SimpleSchema({
  format: {
    type: String,
    label: 'Format of imported Data',
    defaultValue: 'start	end	item	comments',
    max: 2000,
  },
  delimiter: {
    type: String,
    label: 'Delimiter',
    defaultValue: '\t',
    optional: true,
    max: 3,
  },
  dateformat: {
    type: String,
    label: 'Format of imported date values',
    defaultValue: 'DD.MM.YY HH:mm',
    optional: true,
    max: 100,
  },
  data: {
    type: String,
    label: 'CSV Data to import',
    defaultValue:
      '20.03.16 11:00	20.03.16 12:00	Item Title	comment, comment, comment',
    autoform: {
      afFieldInput: {
        type: 'textarea',
        rows: 10,
      },
    },
  },
  origin: {
    type: String,
    label: 'Name the source of this list',
    max: 200,
    optional: true,
    defaultValue: `Import from ${moment().format(CNF.FORMAT_DATETIME)}`,
  },
});

Schemas.SearchSimple = new SimpleSchema({
  searchitem: {
    type: String,
    regEx: SimpleSchema.RegEx.Id,
    label: 'Search Items',
    optional: true,

    autoform: {
      class: '',
      autocomplete: 'off',
      type: 'select2',
      autofocus: 'autofocus',
      // select2Options: itemoptions,
      options() {
        return Items.find({}).map(function(item) {
          return {
            label: item.title,
            value: item._id,
          };
        });
      },
      select2Options() {
        return {
          // tags: true,
          placeholder: 'Search for an Item',
          // allowClear: true,
          // tokenSeparators: [',', ';'],
          escapeMarkup(markup) {
            return markup;
          },
          templateResult: formatItemResult,
          templateSelection: formatItemResult,
        };
      },
    },
  },
});

Schemas.TimeRunning = new SimpleSchema({
  timeId: {
    type: String,
    regEx: SimpleSchema.RegEx.Id,
    label: 'Time Entry',
    autoform: {
      type: 'hidden',
      label: false,
    },
  },
  comment: {
    type: String,
    label: 'Comment',
    // optional: true,
    max: 200,
  },
  createdAt: {
    type: Date,
    label: 'Created at',
    optional: true,
    // defaultValue: new Date(),
    autoValue() {
      console.log('createdAt autovalue TimeRunning: ');
      console.log(this);
      // if(this.isInsert) {
      return new Date();
      // }
    },
    // denyUpdate: true,
    autoform: {
      type: 'hidden',
      label: false,
    },
  },
});

SimpleSchema.messages({
  unauthorized: 'You do not have permission to update this field',
  notUnique:
    'The given value is already taken, but needs to be unique. Please enter another value',
});
